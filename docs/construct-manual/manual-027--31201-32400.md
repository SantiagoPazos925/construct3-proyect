# Manual Construct 3  Parte 27 (líneas 3120132400)

## Resumen
- JavaScript essentially just by deleting the type annotations. This illustrates how closely related (línea 7)
- the languages are - TypeScript is essentially adding a layer of additional checks on top of (línea 8)
- JavaScript. (línea 9)
- Some of the advantages and disadvantages of JavaScript vs. TypeScript are: (línea 14)
- Ease of learning: TypeScript may take a little longer to learn as you have to also learn about (línea 15)
- type annotations. (línea 16)
- you even try to run your project. JavaScript on the other hand allows many kinds of incorrect (línea 18)
- code to execute, and you may only be able to find out the problem from either the browser (línea 19)
- console or using a debugger. (línea 20)
- Coding flexibility: JavaScript allows writing a wider range of code styles, allowing things that (línea 21)
- TypeScript would not normally allow due to its type checking (but as noted previously that (línea 22)
- also includes incorrect code). (línea 23)
- Autocomplete: TypeScript allows providing an exact autocomplete feature. As JavaScript is (línea 24)
- a dynamic language it is not possible to always accurately identify which properties and (línea 25)
- methods are available, and so often the autocomplete list will include guesses which are not (línea 26)
- actually valid, or miss out possible entries. (línea 27)
- Other developer tools: TypeScript also allows other tools like Go to definition and Find (línea 28)
- references to work accurately thanks to its type system, whereas much like with (línea 29)
- autocomplete in JavaScript these may resort to guesses or miss out some results. (línea 30)
- If you are new to coding and wondering which to learn, we would suggest to consider starting (línea 31)

## Contenido

JavaScript essentially just by deleting the type annotations. This illustrates how closely related
the languages are - TypeScript is essentially adding a layer of additional checks on top of
JavaScript.
Page 879 of 1146

Construct 3 Official Manual

Some of the advantages and disadvantages of JavaScript vs. TypeScript are:
Ease of learning: TypeScript may take a little longer to learn as you have to also learn about
type annotations.
Coding accuracy: TypeScript's type checks can catch lots of kinds of errors for you before
you even try to run your project. JavaScript on the other hand allows many kinds of incorrect
code to execute, and you may only be able to find out the problem from either the browser
console or using a debugger.
Coding flexibility: JavaScript allows writing a wider range of code styles, allowing things that
TypeScript would not normally allow due to its type checking (but as noted previously that
also includes incorrect code).
Autocomplete: TypeScript allows providing an exact autocomplete feature. As JavaScript is
a dynamic language it is not possible to always accurately identify which properties and
methods are available, and so often the autocomplete list will include guesses which are not
actually valid, or miss out possible entries.
Other developer tools: TypeScript also allows other tools like Go to definition and Find
references to work accurately thanks to its type system, whereas much like with
autocomplete in JavaScript these may resort to guesses or miss out some results.
If you are new to coding and wondering which to learn, we would suggest to consider starting
with TypeScript. Despite the fact there is a little more to learn, its extra checks mean it catches
lots of kinds of beginner mistakes, and the precise autocomplete helps you more quickly identify
what kind of code you can write.

Terminology
JavaScript is often shortened to JS and normally uses files with the extension .js. TypeScript is
often shortened to TS and normally uses files with the extension .ts. The terms script and code
refer to the same thing: the programming code that you or someone else has written. Similarly
scripting, coding and programming are used interchangeably, and all refer to the process of
writing code in a programming language. In the context of Construct these terms refer to
JavaScript or TypeScript code, as those are the two languages it supports.

Quick start guide
If you already know JavaScript, check out the Construct for JavaScript developers quick start
guide for a summary of what you might need to know when working in Construct. If you already
know TypeScript, you can also check out the Construct for TypeScript developers quick start
guide.
If you'd also prefer to use an external code editor like VS Code, see Using an external editor.

Learning JavaScript

Page 880 of 1146

Construct 3 Official Manual

If you're interested in learning JavaScript from scratch using Construct, see our 13-part tutorial
series Learn JavaScript in Construct.
JavaScript is one of the most popular languages in the world, and is widely used in the
technology industry, especially in web development. As a result there are many more materials
available across the web for teaching the JavaScript language. The tutorial series linked to above
includes lots of links towards the end where you can continue learning more about JavaScript.
This manual section focuses on the unique details of using JavaScript within Construct. We
recommend the MDN web docs as a good reference to use for the JavaScript language itself.
This manual links to it when referring to specific parts of the JavaScript programming language
so you can learn more about it.

Introductory video
For a video introduction to using JavaScript in Construct, see the video below.
JavaScript coding in Construct (updated)

Subscribe to Construct videos now

Learning TypeScript
If you're interested in learning TypeScript from scratch using Construct, see our 14-part tutorial
series Learn TypeScript in Construct.
As with JavaScript, TypeScript is one of the most popular languages in the world, and is widely
used in the technology industry, especially in web development. The tutorial series linked to
above also includes lots of links towards the end where you can continue learning more about
TypeScript.
The official TypeScript website provides lots of useful guides and information, including:
TypeScript for the New Programmer
TypeScript for JavaScript Programmers
The TypeScript Handbook
See also the guide Using TypeScript in Construct.

Examples
Page 881 of 1146

Construct 3 Official Manual

In the Example Browser you can filter for JavaScript or TypeScript examples under the Coding
header. You'll find a variety of example projects making use of JavaScript/TypeScript coding in
Construct, including many examples that come with both JavaScript and TypeScript variants.
These cover everything from simple beginner examples to sophisticated fully-coded games.
The reference section of the manual also includes some code samples in places, with snippets
demonstrating how to use specific features. These will usually need to be pasted in to a project
with appropriately named objects and behaviors to work correctly, or otherwise edited as
necessary for use in your own projects.

Page 882 of 1146

Construct 3 Official Manual

CODING IN CONSTRUCT
View online: https://www.construct.net/en/make-games/manuals/construct-3/scripting/using-scripting/codingin-construct

This section covers some details about how JavaScript and TypeScript code is run in Construct.

Expressions aren't exposed to script
Construct's event sheets fundamentally work differently to code. Consequently object
expressions that you may enter in to conditions and actions are not directly accessible from
script. Refer to the scripting reference for the methods and properties that are directly
accessible from scripts. You can also still indirectly access things that are not directly exposed
to scripts by passing values between scripts and event sheets - for an example of that see
integrating events with script.

Case sensitivity
Many features in Construct are case insensitive, such as "Player" being considered equivalent to
"player". However like most programming languages, JavaScript and TypeScript are case
sensitive. Therefore when referring to objects, variables and other items in your project from
code, you must use the same case as it was written with in Construct.

Modules
All scripts in Construct are Modules (also known as ES Modules, or ESM). This allows use of the
import and export syntax. It also has a few differences to legacy "classic" mode scripts,
notably:
1

Each module (script file) has its own top-level scope. This means top-level declarations are not
globally accessible. Instead prefer to use imports and exports, or if you have to, explicitly use
properties of globalThis to make them global.

2

Modules run code in strict mode. This eliminates common problems such as silent errors, typos
accidentally creating variables, and fixes some aspects of the language considered mistakes. In
particular it helps avoid confusing problems that beginners often run in to. Since all code is
already run in strict mode, there is no need to add the "use strict" directive to any of your
code.

See the Imports & exports example for a demonstration of using modules in Construct.

Worker mode
When the Use worker project property is Yes, the Construct runtime is hosted in a Web Worker
instead of in the DOM, and renders using an OffscreenCanvas. This is generally good for

Page 883 of 1146

Construct 3 Official Manual

performance since the runtime can run independently of the browser main thread, which can be
blocked by browser tasks like layout. However Web Workers have a reduced set of APIs
available. Notably there are no window or document objects available, and so the DOM cannot
be directly accessed. However there are many other APIs still available, such as fetch (and the
older XMLHttpRequest), IndexedDB, WebSocket and others - see Functions and classes available
to workers for more details.
The default mode for Use worker is Auto. This means Construct automatically decides whether
to run your project in a Web Worker or the DOM. Currently this means it will run in a worker
unless your project uses any JavaScript code, in which case it will run on the DOM on the
assumption your code will need to make use of DOM APIs. Note however that this loses the
performance benefits of worker mode. If your JavaScript code can run in a Web Worker, you can
change the setting back to Yes and gain the performance benefits.

Worker mode with TypeScript
When using TypeScript, Construct will update type definitions to match the environment. In other
words if your project runs in a worker, it will use type definitions for a worker, so accessing
things like document will be an error. Otherwise if the project runs in the DOM then it uses type
definitions for the DOM, permitting the use of such DOM-specific APIs.

Accessing global scope
Sometimes the window object is used to refer to global scope, such as with window.myGlobal =
1; . Note however that the window object is not available in worker mode, so this won't work
there.
The standard way of accessing the global scope is with globalThis , such as with
globalThis.myGlobal = 1; . Since this is available in both the DOM and Web Workers, this code
will work everywhere.

Browser/platform support
When using the very latest JavaScript features, you may need to check which browsers support
it. For example if you use a JavaScript feature that not all browsers or platforms support, you
may get an error trying to run your game on that platform. We recommend the MDN web docs
as a good place to check compatibility.
This also applies when using TypeScript. Since TypeScript essentially just deletes type
annotations and then runs the code as JavaScript, you still need to be aware of browser support
for any newer JavaScript features you use.
You can also rely on modern support for JavaScript being available, because Construct only
supports relatively modern browsers. For example the C3 runtime does not support Internet
Explorer so you do not need to worry about supporting it at all. Note many older code examples
across the web use an older style designed to support defunct browsers. For example many old
code examples use var to declare variables, whereas in modern JavaScript let and const

Page 884 of 1146

Construct 3 Official Manual

are preferred. Bear this in mind when looking at other code examples, and note there may be
modern features that can considerably simplify the code. It can be a good idea to update any
code snippets you use in your projects to a modern style.

Undocumented features
Do not use undocumented features in your JavaScript code.
If you explore the functions and variables available in a debugger, you may find undocumented
APIs specific to the Construct engine. The only reason these can be found is because the way
JavaScript works makes it difficult to hide them. Do not use any such undocumented features
in your JavaScript code. These are internal details of the Construct engine and can change at
any time, and such changes can easily break your code. No support will be provided for
undocumented APIs, even if engine changes break your code. Responsible developers know to
only use documented and officially supported APIs. These can be found in the scripting
reference. If new engine functionality is essential to you, please file a feature request.
Note this only applies to the Construct engine - all other browser APIs are of course available for
use.
When using TypeScript, type definitions are only provided for documented features, so it will
prevent you using undocumented features. This can be circumvented with the any type, but
naturally we would strongly advise against that.

Page 885 of 1146

Construct 3 Official Manual

TYPESCRIPT IN CONSTRUCT
View online: https://www.construct.net/en/make-games/manuals/construct-3/scripting/usingscripting/typescript-construct

There are a few details specific to using TypeScript in Construct. This section outlines what you
need to know.

TypeScript in the Construct editor
If you are writing TypeScript code in Construct itself, you should only have TypeScript files (.ts) in
your project. Construct will automatically compile these to JavaScript (.js) files for you behind
the scenes, so you don't need to worry about having .js files in your project. The only times you'll
see the JavaScript output of your TypeScript code is when debugging or after exporting your
project.
If you do have both a .ts and a .js file with the same name in your project, Construct gives priority
to the .js file. In other words it will ignore your .ts file and just use the contents of the .js file.

Using an external editor
If you use an external editor to write TypeScript code, you most likely want to keep the .ts files
external, and only import the .js output files to your Construct project. This is because your
external code editor will use its own version of TypeScript. Using two different versions of
TypeScript is likely to cause awkward compatibility problems, so the best workflow is to let your
external editor compile TypeScript to JavaScript, and then just use the .js files in Construct so it
uses them as-is. You can set your code editor to automatically compile TypeScript to JavaScript
when saving a file, and set Construct to auto-reload the script files on preview, so then you can
have an easy workflow where saving a TypeScript file will automatically reflect the changes in
the next Construct preview.
Using an external editor also allows you to use a newer or different version of TypeScript to the
one built in to Construct. Construct's built-in TypeScript version is logged to the browser console
the first time a code editor is opened.

Suggested workflows
In short the two suggested workflows for TypeScript coding are:
1

Code TypeScript in the Construct editor: only have .ts files in your Construct project, and no .js
files.

2

Code TypeScript using an external editor: don't have .ts files in your Construct project, only .js
files.

TypeScript definition files
Page 886 of 1146

Construct 3 Official Manual

You can import .d.ts files - aka TypeScript definition files - to your Construct project. This will
allow TypeScript to use the type definitions in those files. As per the design of TypeScript,
definition files are not compiled to JavaScript and have no effect on how code is run - they only
define types to be used by TypeScript's code validator.

Converting a project to TypeScript
You can switch an existing project using JavaScript code to TypeScript by right-clicking the
Scripts folder in the Project Bar and choosing TypeScript►Switch project to TypeScript. This will
automatically switch all JavaScript code in event sheets to use the TypeScript language instead,
and rename all .js project files to .ts. Note however it does not change any code, as it is not
possible to automatically add type annotations. Therefore you will still need to go through your
code and add type annotations until there are no more TypeScript errors (see the next section
for advice on that). However this option should still save you some time if you want to switch
your project's language.
Similarly a project using TypeScript can be switched back to JavaScript. Again you'll need to
then remove type annotations for it to be valid JavaScript code.

Converting a folder project to TypeScript
Construct has special handling for switching a folder-based project to TypeScript. This applies
when there are both .js and .ts files in the project folder, but only .js files in the Construct project
(i.e. our recommended workflow for using an external editor). In this case choosing the Switch
project to TypeScript option will instead replace .js files in the Construct project with the
corresponding .ts files from the project folder. This provides a handy way to switch a project
from using an external editor back to using Construct's built-in TypeScript support.

Adding types to existing JavaScript code
If you convert a JavaScript project to TypeScript, you'll probably see a lot of TypeScript errors.
That's because in some places TypeScript requires type annotations, and leaving them out is
marked as an error. You'll need to go through all the code adding type annotations until there are
no more TypeScript errors reported. This section has some advice on how to do that. Note this is
not an exhaustive list of all changes you'll need to make, but the common changes that you're
likely to need to make are covered, as well as some advice specific to Construct.
As a starting example, the default main.js code file includes this function:
async function OnBeforeProjectStart(runtime)
{
// ...
}

TypeScript will identify the runtime parameter as an error, because it does not have a required
type annotation. Construct's runtime interface type is IRuntime. So the parameter must be
marked as having the type IRuntime , as shown below.
Page 887 of 1146

Construct 3 Official Manual

async function OnBeforeProjectStart(runtime: IRuntime)
{
// ...
}

In many cases TypeScript can automatically infer types from existing code (see Type inference)
so a type annotation is not always needed in every place in the code. However there are several
places like function parameters that will need type annotations to be added. Familiarity with
Construct's built-in class names is useful as they are sometimes needed as types, such as
IRuntime above - all the class names are included in the scripting reference section of the
manual.

Instance types
When using TypeScript, Construct generates a special class representing an instance for every
object type and family in the project. This includes type definitions for things like the instance
variables, behaviors and effects specific to that object. These classes are all in the
InstanceType namespace with the name of the object. For example InstanceType.Player is
the type for an instance of the Player object type.
Construct's naming rules are more permissive than JavaScript/TypeScript's naming rules, so
in some cases the generated class name may be different to the object type name. The best
approach is to make sure all your object names are valid JavaScript identifiers, which
generally means starting with an alphabetic letter.

Optional types
Many of Construct methods, such as objectType.getFirstInstance() , can return null (in this
case, if no instances exist at all). This means the method's return type can optionally be null .
TypeScript will show an error if you try to use something that could be null . An example of this
is shown below.
const playerInst = runtime.objects.Player.getFirstInstance();
playerInst.x += 10; // Error: 'playerInst' is possibly 'null'

If you know for sure that there is always an instance of the object and so it will never return
null , you can add an exclamation mark ! after the expression to tell TypeScript you know it
won't be null .
// Note '!' added to line below
const playerInst = runtime.objects.Player.getFirstInstance()!;
playerInst.x += 10; // OK

This is known as the non-null assertion operator.
Page 888 of 1146

Construct 3 Official Manual

Subclassing
If your project uses subclassing to customize the instance class for Construct objects, then
you'll find some Construct APIs still return instances of the default type. For example instances
of a Globin sprite object will be typed as the default InstanceType.Goblin instead of a custom
GoblinInstance class, e.g.:
const inst = runtime.objects.Goblin.getFirstInstance()!;
// 'inst' is of type InstanceType.Goblin - so it won't have any of
// the properties or methods of the custom GoblinInstance class

To solve this, the methods available on IObjectType are in fact generic, so you can make them
return the correct type. This means adding the <Type> generic syntax like so:
const inst = runtime.objects.Goblin.getFirstInstance<GoblinInstance>()!;
// 'inst' is now of type GoblinInstance and so can use the properties
// and methods of the custom class

Note that you may then have to import the module that defines GoblinInstance , as
otherwise TypeScript doesn't know about its type.

Object literals
Sometimes it's useful to write an object literal, which the Spell Caster Code example does for
sharing global variables from a module, similar to this:
const Globals = {
score: 0,
playerInstance: null
};

In this case, TypeScript will correctly infer the type of score as number, but it will infer the type
of playerInstance as null. The type null means the variable can only ever have the value null
and assigning anything else to it will be an error! Due to the syntax of object literals, which
already use a colon, it's not always obvious at first how to add a specific type to this property.
The solution is to use the generic-style syntax <Type> like so:
const Globals = {
score: 0,
playerInstance: <InstanceType.Player | null> null
};

Class properties
Commonly in JavaScript, class properties are added in the constructor.
Page 889 of 1146

Construct 3 Official Manual

class MyClass {
constructor()
{
this.prop1 = "hello";
this.prop2 = 123;
}
}

TypeScript does not infer the class properties from the constructor, so it will show an error for
prop1 and prop2 , e.g. Property 'prop1' does not exist on type 'MyClass'. Instead you must
declare the class properties, and their types, at the class-level like so:
class MyClass {
prop1: string;
prop2: number;
constructor()
{
this.prop1 = "hello";
this.prop2 = 123;
}
}

Note JavaScript does allow class property definitions in a similar way, with the feature known as
class fields. Using this feature in JavaScript should make it easier to switch to TypeScript, as you
can then just add type annotations to the existing class fields.

Imports
Typically when importing other JavaScript files in your project, you'd write a relative import for
another .js file like so:
import Globals from "./globals.js";

How do you write the import for TypeScript? The answer is: exactly the same way! Even though
the import ends with .js, TypeScript knows the file is really generated from the .ts file, and so
everything just works. Don't try to change it, as otherwise it won't work after it's compiled to
JavaScript.

Example
The Spell Caster TypeScript example demonstrates the Spell Caster JavaScript example but
updated to use TypeScript. In the Example Browser you can find a number of examples that have
both JavaScript and TypeScript variants, which allows you to compare them and identify what
changes were made. You can also try practicing by taking a JavaScript example, using the
Page 890 of 1146

Construct 3 Official Manual

Switch project to TypeScript option, and adding type annotations; if you get stuck, check the
TypeScript version to see what the solution is. Usually if a non-obvious change was needed for
TypeScript, the project will contain a special comment explaining what was done.

Page 891 of 1146

Construct 3 Official Manual

SCRIPTS IN EVENT SHEETS
View online: https://www.construct.net/en/make-games/manuals/construct-3/scripting/using-scripting/scriptsin-event-sheets

A great way to get started with JavaScript or TypeScript is writing snippets of code in the event
sheet. You can write some code to run in the place of an action or an event block.
In the context of JavaScript/TypeScript, an event commonly refers to a callback function
that runs when something happens, similar to a trigger in Construct's event sheets. However
the term event is also used in Construct to refer to a block in an event sheet. To clarify the
difference the scripting section of the manual refers to event blocks or event sheets to refer
to Construct's event system.

Scripts in actions
JavaScript or TypeScript code can be added as an action. The code runs whenever the action is
run, i.e. after all the event's conditions are met, and all previous actions have run. To add some
code as an action, use the Add... menu to the right of the Add action link, and select Add
JavaScript or Add TypeScript. Alternatively you can use the J or T keyboard shortcuts
respectively when an action is selected.

A code editor will appear for you to enter the code to run.

Scripts in blocks
Alternatively JavaScript or TypeScript code can be added as a block, in the same place as other
event blocks appear. The code runs whenever an event block in that place would be run. You can
add a script block using any of the following methods:
1

Right-click in the margin of an existing event block and select Add►Add JavaScript or Add►Add
TypeScript

2

Click the Add... menu at the end of a group, or the end of the event sheet, and select Add
JavaScript or Add TypeScript
Page 892 of 1146

Construct 3 Official Manual

3

Use the J or T keyboard shortcuts when an event block is selected (note if an action is selected,
a script action will be inserted instead)

Remember that the event sheet runs all events in top-to-bottom order every tick, so a script in a
block at the top level of an event sheet is run every tick (as if it was an action in an Every tick
event). Often it is more useful to use script blocks as sub-events, which only run if their parent
event block was true.

Using 'await'
Code written in either a script action or script block is actually run inside an async function. This
means your code can use the await keyword. For example you can await the result of a fetch
over the network.
Note that the rest of the event sheet will continue to run while await waits for its result. In other
words, await pauses the script execution and any actions after the code will immediately run.
Then once the awaited promise resolves, any code after the await will then run - which will be
after the following actions have run. You can change this using the System action Wait for
previous actions to complete: this will wait for any code blocks before it to finish before running
the following actions.

Using imports
Since code in a script action or script block is run inside a function, you cannot use import or
export statements inside scripts in event sheets, since the JavaScript/TypeScript
programming languages do not permit these inside functions.
Instead you can import things in to a script file with the purpose Imports for events, normally
named importsForEvents.js. For example if you add the following JavaScript line in the Imports
for events script:
// importsForEvents.js
import * as Utils from "./utilities.js";

...then all your JavaScript code in script actions and script blocks can use the exports in Utils,
e.g. Utils.myExport() . This provides a useful way to write a library of functions that can be
used by code anywhere else in the project, and is another good way to closely integrate event
sheets with code.
Do not export anything in your Imports for events script. This does not work because
Construct combines this script with other content and then renames it. Therefore nothing
else can import the Imports for events script file as it does not really exist, and so there's no
point exporting anything from it either. If you need to share content between scripts, put it in
a separate script and import it to the Imports for events script.

Page 893 of 1146

Construct 3 Official Manual

Note that Imports for events scripts are language-specific. If you add a JavaScript Imports for
events file, then it only applies to JavaScript code in event sheets - it will not apply to TypeScript
code in event sheets - and vice versa. You can have both a JavaScript and TypeScript Imports for
events file in the same project, but it is recommended to use either all JavaScript or all
TypeScript to avoid creating confusing situations where the two Imports for events files have
different contents.

Using the runtime interface
All scripts in the event sheet can access a special runtime variable which refers to the runtime
script interface. This provides functions and properties that lets your code access and control
Construct's runtime. This also includes ways to closely integrate code and events, such as
iterating the instances picked by the current event.
A very simple example is shown below, which can be used to show a dialog box with the project
name in it.
alert(runtime.projectName);

Accessing local variables
A useful way to pass values between scripts and the event sheet is to use local variables in the
event sheet. These can be accessed by both script actions and script blocks using the variable
name localVars . This is set to an object with a property for each local variable in scope. The
available local variables are the same as are available to a Set value action in the same place.
This includes any parameters for event sheet functions.
For example a script in an event group with a local variable named temp can access the local
variable using localVars.temp . A useful pattern is to use an action to set a local variable to an
expression, and then read from it in a following script action. Alternatively a script could
calculate a value and assign it to a local variable, to subsequently be used in the event sheet. It
could also be used both ways at once, both reading the variable and then assigning it. See also
the Integrating events with script example which shows one of the ways this can be used.
Note that localVars excludes global variables, which are available via runtime.globalVars
instead. localVars is also unique to scripts in the event sheet - script files cannot access it,
because they do not have a scope in the event sheet.
In some cases, event variables may have names that aren't valid JavaScript/TypeScript
identifiers. In this case you can use the string property syntax, e.g. localVars["temp"] .

Errors
Any exceptions, or rejected promises, arising from a script in an event sheet will be caught by the
Construct engine and logged to the console with information about where the error came from.
This means unhandled exceptions or rejections will not crash the game (since browsers stop
Page 894 of 1146

Construct 3 Official Manual

running scripts if they encounter an unhandled error). However you should keep an eye on the
browser console to check for any unexpected errors. For more information see the section on
debugging script.

Page 895 of 1146

Construct 3 Official Manual

SCRIPT FILES
View online: https://www.construct.net/en/make-games/manuals/construct-3/scripting/using-scripting/scriptfiles

For those more familiar with coding, script files provide a code editor to write a JavaScript or
TypeScript file which works independently of an event sheet.

Adding script files
Script files can be added in the Scripts folder of the Project Bar. Existing JavaScript files (.js) and
TypeScript files (.ts) can also be imported using the Import scripts option instead.

Once you add a script a code editor appears. The first script added will have some default code
added to help you get started.

Execution of the main script
Construct loads only the main script just after the Construct engine scripts run on startup. This
is before any loading screen appears. It is a good place to write any initialization code and
imports/exports the entire project will use. Since the Construct engine has still not yet initialized
at this point, there is no runtime variable (representing the runtime script interface) available at
the top level. Instead Construct provides a special runOnStartup function that runs a callback
once the runtime is ready, and provides the runtime variable as a parameter.
runOnStartup(async runtime =>
{
// This code runs on startup with
// the 'runtime' variable available
});

The callback can be an async function, meaning the await keyword can be used inside it, so
this is a convenient place to run any asynchronous initialization while also making use of the
runtime script interface.
Note that the callback runs when the loading screen appears. The project is not yet fully loaded
and no objects exist yet. Therefore any code that attempts to interact with objects in your project
Page 896 of 1146

Construct 3 Official Manual

in that callback won't work. Instead you'll need to wait for the "beforeprojectstart" event,
which fires just before the first layout starts running.
runOnStartup(async runtime =>
{
// Wait for "beforeprojectstart" event
runtime.addEventListener("beforeprojectstart", () => OnBeforeProjectStart(runtime));
});
async function OnBeforeProjectStart(runtime)
{
// Now the project is loaded and objects exist.
// You can interact with objects etc. here.
}

Note that the function for the "beforeprojectstart" event can be async, and Construct will wait
for it to complete before the project starts running. This means you can also use await in case
you need to do any asynchronous initialization there.

Continuing execution
The only code in the main script that is automatically executed is the top-level scope and any
runOnStartup callbacks. Beyond that no code in your script will run any more, unless you add
event listeners to run callbacks, as previously shown with "beforeprojectstart" . The main
other event to listen for is the runtime "tick" event. Since this fires every tick it provides a good
place to keep running code throughout your game. The JavaScript code example below
demonstrates a typical way to use this.
runOnStartup(async runtime =>
{
runtime.addEventListener("beforeprojectstart", () => OnBeforeProjectStart(runtime));
});
async function OnBeforeProjectStart(runtime)
{
runtime.addEventListener("tick", () => Tick(runtime));
}
function Tick(runtime)
{
// Code to run every tick.
// Note 'runtime' is passed.
}

Using additional scripts
Page 897 of 1146

Construct 3 Official Manual

As noted previously, the only script Construct automatically loads and runs is the main script.
This appears in bold in the Project Bar.
When you select script files, the Properties Bar shows a Purpose property for the script. The
main script has the purpose set to Main script, and you can only have one main script in your
project.
Since you can only have one main script, you must choose whether the main script is JavaScript
or TypeScript. There is some support for mixing JavaScript and TypeScript code, but you may
find it easier to choose one language to use throughout your project.
To use any other script files in your project, you must import them in the main script. This also
lets you control the order they are loaded and run. These other script files should have the
Purpose set to '(none)' (indicating Construct won't use it automatically) and also export the
things it wants to be used by other scripts. See the Imports & exports example for a basic
demonstration of using modules in Construct.
To learn more about imports and exports, refer to the MDN guide on JavaScript Modules.

Using external scripts
Sometimes you want to load a separate script file that is external and not loaded via an import.
A good example of this are Web Workers - you may use something like new
Worker("myworker.js") , where "myworker.js" must always be in a separate file.
You should place these script files in the Files folder of the Project Bar instead of the Scripts
folder. The reason for this is Construct has special processing for everything in the Scripts folder,
including moving the files to a different folder on export, or minifying all the scripts there, and
these steps can cause the worker script file to stop working after export. On the other hand
script files in the Files folder are not processed and are just copied as-is on export, so things like
worker scripts will work consistently both in preview and export.

Integration with scripts in events
Construct loads all script files as modules. Unlike legacy "classic" mode scripts, modules have
their own top-level scope. This means things like a top-level function declaration is not available
in other script files.
Instead you can add imports to the script file with the purpose Imports for events which then
become available for scripts in events. See the section Using imports in Scripts in event sheets
for more details.
Another option is to write globals as explicit properties of globalThis , e.g.
globalThis.myFunction = function () { ... } and call it via globalThis.myFunction() , but
using modules is preferable.

Errors
Page 898 of 1146

Construct 3 Official Manual

Unlike scripts in event sheets, errors arising from the top level of script files are not
automatically handled by Construct. If an unhandled exception is thrown, the browser will halt
any further execution of script in that file. Typically this causes the rest of your code to stop
working, and is considered a crash. See the section debugging scripts to find out how to deal
with such issues.
Note one difference is exceptions or rejections in a runOnStartup callback are automatically
handled by Construct. The error will be logged to the browser console and the runtime will
continue to start up and run the game - but note if an error occurred it may not run as expected.

Page 899 of 1146

Construct 3 Official Manual

DEBUGGING SCRIPT
View online: https://www.construct.net/en/make-games/manuals/construct-3/scripting/usingscripting/debugging-script

Browsers provide comprehensive developer tools ("dev tools" for short) to help debug and profile
JavaScript code. Construct is designed to allow you to use these industry-standard tools to also
debug code used in your project.
Developer tools are complex and sophisticated tools used by professional developers. For full
documentation you should refer to each browser's own dev tools documentation, such as
Google's Chrome DevTools documentation. However an overview is provided here, focusing on
how to use dev tools with Construct specifically. Screenshots of dev tools are taken from
Chrome's DevTools, as it is the most widely-used browser, and is also the dev tools used with
NW.js. Other browser's dev tools will look different, but generally they work in similar ways.

Debugging TypeScript
Browsers only directly support running JavaScript code. The way TypeScript works is it compiles
the code in to JavaScript before running it, which generally amounts to deleting the type
annotations. When debugging code written in TypeScript you'll actually find the compiled
JavaScript output of your TypeScript code in the browser developer tools, all using the .js file
extension rather than .ts. However this should not be a significant hindrance - it should look
pretty much the same, including with all your comments, and only be missing the type
annotations that TypeScript uses.
As TypeScript compiles to JavaScript for running in the browser, the rest of this section refers to
JavaScript code.

Construct's debugger
It should be noted that Construct's debugger cannot debug JavaScript - only the browser dev
tools can. In an event sheet Construct's debugger can only stop just before running a script
block or script action, and continuing will run all the JavaScript in that block to completion and
then advance to the next block. Construct's debugger has no way to stop on code in script files
at all. Therefore it is not generally useful for debugging JavaScript code.
Using both the Construct debugger and browser dev tools simultaneously is possible, but is
likely to be very confusing. Therefore it is recommended to only use one or the other at a time.

Opening dev tools
First make sure you have a preview window running and focused before opening developer tools.
Otherwise you will open developer tools for the Construct editor, which is not useful, and due to
security issues will show a warning in the console.
Page 900 of 1146

Construct 3 Official Manual

Once a preview is running, in most browsers you can press F12 to open developer tools. In
Safari, use ⌥⌘I.
Normally the dev tools window can be undocked, so it appears in its own window. This is the
easiest way to see the largest possible dev tools window, which is important for more advanced
tasks like debugging JavaScript code.
For more information, including using remote debugging to open developer tools for a mobile
device, see the tutorial Checking for errors in browsers.

The console
The Console tab provides a list of messages, used for development purposes. Calling
console.log("Hello!") will add the message Hello! here. For more console features available in
code, see the Console API. Adding console messages to indicate which parts of the code have
been reached, and the contents of any important variables, can be a useful way to diagnose
code.

You can also directly type in JavaScript code in the console, which runs when you press Enter.
This is a useful way to try out snippets of code or quickly write and test a function to use in your
project. If you are stopped on a breakpoint, code run in the console can also use any variables in
the scope of the breakpoint. Often this is useful if you break in some code with the runtime
variable available, allowing you to call runtime script interface functions from the console.
Remember that browsers can only directly run JavaScript code. Therefore you can only type
JavaScript code in to the console - you can't enter TypeScript code there.

Debugging JavaScript code
A more sophisticated tool is the JavaScript debugger. This is an incredibly powerful tool that
allows you to pause JavaScript execution at any point, and inspect and alter the full state of your
program. Normally this can be found in the Sources tab of dev tools.

Finding your scripts
You can find any script files in your project in this section of the debugger. For example if you
add MyScript.js to your project, it will be listed here (normally on the left). Sometimes a unique ID
may be appended to the name, but you can ignore that. The file should appear under the origin
preview.construct.net, since that is the domain that project previews run on.

Page 901 of 1146

Construct 3 Official Manual

In worker mode, the scripts will instead appear under a Web Worker named Runtime.
There may also be a special script file named javaScriptsInEvents.js. As the name suggests, all
JavaScript code used in event sheets appear in this file. Each code block appears as a function
whose name is derived from its location in the event sheet, such as EventSheet1_Event1_Act1.
There may also be typeScriptInEvents.js which is the same but for all TypeScript code used in
event sheets, but note this is also the JavaScript output of compiling the original TypeScript file.
Messages logged to the browser console also identify where they came from. You can click the
location that logged the message to open that script in the debugger, which is a useful way to
jump to the relevant code.

Using breakpoints
Once you have opened a script file in the debugger, you can add a breakpoint by clicking in the
margin of the file, where the line numbers appear. The breakpoint can be removed by clicking it
again. When the breakpoint is present, just before that line of code runs all script execution will
pause and the debugger will highlight that line, allowing you to inspect the state of your code. In
this state you can hover the mouse cursor over variables to see their values, look at the call
stack, and even run code in the console to alter the state of the program or call functions.

Page 902 of 1146

Construct 3 Official Manual

Execution will not continue until you resume the debugger. Normally there is a Continue button
for this. There are also features to step one line at a time, jump in to or out of functions, and so
on. With keyboard shortcuts experienced developers can comfortably control execution of their
code through a debugger, watching how the program runs at every step.
You can also use the special debugger statement in code:
debugger;

Whenever this line of code runs, the debugger will automatically stop as if there was a
breakpoint on that line. However it will always do this until you delete the statement from your
code, whereas normal breakpoints can be removed at any time.

Breakpoints on startup
Breakpoints, including the debugger statement, only ever stop when dev tools are open. If you
want to stop on a breakpoint run on startup, this means by the time you open dev tools, the code
has already run without stopping. This can be solved by reloading the preview window once you
have opened dev tools. Press F5 with the preview window focused to refresh it, or right-click the
caption and select Reload. (Some debuggers also provide a reload button.) Since the preview
window reloads with dev tools open, all breakpoints in startup code will be able to stop.

Avoiding stepping in to runtime code
While debugging code that makes lots of calls to the runtime APIs, you may find yourself
regularly stepping in to the internal runtime code. This is not normally useful as you only really
want to debug your own code.
You can avoid the debugger ever stepping in runtime code by ignoring the runtime scripts. The
debugger will avoid ever showing you an ignored script, even if you try to step inside it. In
Chrome you can ignore a runtime script if you step in to it, right-click the code, and then select
Add script to ignore list.

More tools and techniques
Browsers also provide advanced capabilities like profiling performance, tracking all network
requests, and more. Many other debugging tools are also provided. This section has only
scratched the surface; over time you'll find and learn useful debugging techniques that will help
you learn to quickly diagnose problems in your code and fix them. These are invaluable tools that

Page 903 of 1146

Construct 3 Official Manual

experienced developers cannot live without! For beginners, learning to use a debugger and step
your code one line at a time is also a very useful technique. It will show you, step-by-step, exactly
what your code is doing. This helps you learn the flow of a program and often helps reveal the
cause of a problem in an obvious way, where you'd be completely stuck without it.

Page 904 of 1146

Construct 3 Official Manual

USING AN EXTERNAL EDITOR
View online: https://www.construct.net/en/make-games/manuals/construct-3/scripting/guides/using-externaleditor

Construct provides its own built-in code editor based on Monaco to help you conveniently write
code in your project. However you may wish to use an external code editor, such as an industrystandard tool like Visual Studio Code (aka VS Code). Construct has special features to help you
use external editors, and this guide describes how they work.
Using TypeScript requires some extra steps which are detailed below. However the basic setup
is explained first, which works well for JavaScript projects.

Step 1: save a folder project
First of all, make sure you save your project to a folder. This means all your project files,
including your script files, are saved as individual files within the project folder, rather than all
contained within a .c3p file. For more information see the section on project folders in Saving
projects.

Step 2: enable auto-reload
Once saved to a folder, right-click the main Scripts folder in the Project Bar, and select the Auto
reload all on preview menu option. After doing that the menu option will appear with a tick to
indicate the auto-reload mode is enabled.
Enabling this setting means that every time you preview in Construct, it will re-load all your script
files from the project folder, ensuring any changes made by an external editor are loaded.

Step 3: open external editor
Now you can open your script files in your favorite external code editing tool like VS Code. If the
tool has an option to open a folder, you probably want to open the scripts subfolder in your
project folder, as that is the folder that contains all your JavaScript code. Then you should be
able to view and edit your project's script files.

Step 4: make changes
Now try making a change in the external editor, save the change, and go to Construct and
preview the project. The changes made in the external editor should be immediately reflected in
preview.
When auto-reload mode is enabled, Construct also shows notifications when you preview
indicating how many script files were changed. If you also have a script file open in Construct
when you preview, Construct will also reload the file from the project folder to show its latest
contents.
Page 905 of 1146

Construct 3 Official Manual

Be warned that in auto-reload mode, if you make a change to a script file in Construct, don't
save the changes, and then preview the project, your changes will be lost as they will be
replaced with the contents of the file in your project file. It's best to consistently edit your
scripts from the same editor to avoid this.

Using an external editor with TypeScript
The previous steps are the basic setup for being able to edit code with an external editor, which
works well with JavaScript. For TypeScript there are some extra steps involved.
To help you get started, this section describes the necessary steps to set up TypeScript with VS
Code, but note the steps may be different for other code editors - refer to their documentation
for specific instructions.

Installation
With some external editors like VS Code, you may need to install TypeScript separately. You will
only need to do this once to set up your code editor.
1

First install VS Code if you haven't installed it already

2

Next, install Node.js if you haven't installed it already

3

Then in a terminal run run the command npm install -g typescript to install TypeScript

You can check the TypeScript compiler, or tsc for short, is installed by running tsc --version
in the terminal. It should print the version installed.
Modern versions of Windows use PowerShell for the terminal, and running some of the
above commands could return an error like tsc.ps1 cannot be loaded because running
scripts is disabled on this system due to the security restrictions set by default. To fix this,
run the command Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope
CurrentUser to allow permission to run the command, and then try the original command
again.
For more details refer to TypeScript in Visual Studio Code in VS Code's official documentation.

Setting up the Construct project
Assuming you've followed the steps above, you've already got a project saved to a folder. There
are some extra steps you need to do to make sure you can use TypeScript with an external editor
though. This includes exporting the TypeScript definitions that Construct uses. To do this, rightclick on the Scripts folder in the Project Bar, and select TypeScript►Set up TypeScript for
external editor. This only needs to be done once per project and performs the initial setup for
using TypeScript in your project. It does three things:
Page 906 of 1146

Construct 3 Official Manual

1

It creates a TypeScript (.ts) file copy of every JavaScript (.js) file in your project. The TypeScript
files aren't shown in the Project Bar, but they'll appear in your project folder. If the project doesn't
have any JavaScript files, Construct creates the initial two default script files main.js and
importsForEvents.js, and then creates TypeScript copies of those.

2

A file named tsconfig.json is created in the project folder. This is a configuration file for
TypeScript. This also does not appear in the Project Bar, as it's just for the external code editor.

3

A subfolder named ts-defs is created with lots of .d.ts files. These are TypeScript definition files,
which tells TypeScript about all of Construct's built-in APIs, as well as some types that are
specific to your project. This also doesn't appear in the Project Bar.

If you run Set up TypeScript again, it won't overwrite any existing tsconfig.json or .ts files. This
means it's safe to run again later on, for example if you add more .js files and want a quick way
to make .ts copies of them.

TypeScript workflow
Once you are up and running, you will likely want to make repeated changes to your TypeScript
code, and easily be able to preview the result in Construct. To make this process work smoothly,
in VS Code, press Ctrl + Shift + B, and then select tsc: watch. This enables a mode where VS
Code will automatically compile your .ts files to .js whenever you save the file. Note this must be
done once per session.
Then, assuming that you have enabled Auto reload all on preview as described above, the
workflow goes like this:
1

You make a change to a TypeScript file and save the change

2

TypeScript then automatically compiles the .ts file to .js (or reports errors if you made a mistake)

3

Then preview the project in Construct, at which point the .js file is re-loaded from the project
folder

Sometimes you may make changes to the project that affect the TypeScript definition files
Construct generated for you. Alternatively when updating to new versions of Construct, the
TypeScript definition files could change too. To make sure the TypeScript definition files are upto-date, right-click on the Scripts folder in the Project Bar, and select TypeScript►Update
TypeScript definitions. This essentially does only step 3 from the Set up TypeScript steps.

Don't add .ts files in Construct
Note that we recommend using the workflow described here, where you only have the .js files in
your Construct project, and the .ts files are only used by the external editor. This basically outsources compilation of TypeScript to JavaScript to your external editor, with Construct only
using the compiled JavaScript output.
If your Construct project has both a .ts and .js version of the same file, Construct gives
precedence to the .js file. This should mean your external editor workflow keeps working as
expected, but there's no reason to keep the .ts file in the project - Construct isn't actually using it
Page 907 of 1146

Construct 3 Official Manual

at all, and so to avoid confusion, we would recommend not having it in your project. In particular
this could be confusing if you try to edit the .ts file from within Construct: it would not change
the .js file and so not affect the way your project works, and auto-reload mode would overwrite
the file on the next preview, so your changes would be lost anyway.
For more advice about TypeScript workflows, see TypeScript in Construct.

Page 908 of 1146

Construct 3 Official Manual

SUBCLASSING INSTANCES
View online: https://www.construct.net/en/make-games/manuals/construct-3/scripting/guides/subclassinginstances

Construct uses the IInstance and IWorldInstance interfaces to provide access to instances.
Many plugins provide derivatives of these to provide plugin-specific APIs. For example the Text
plugin adds a text property with an ITextInstance class that derives from IWorldInstance .
The Plugin interfaces section covers these.
However in your projects it is often desirable to have a further customised class to represent
instances. For example all your Sprite instances will provide an ISpriteInstance interface, but this
is still a fairly generic class to represent many different aspects of your project, such as both the
player and enemies. Subclassing allows you to use your own custom classes like
PlayerInstance or EnemyInstance to represent different objects in your game. Then any time
you ask Construct for instances, such as with getAllInstances(), you'll get references to your
custom classes instead of a generic ISpriteInstance or IWorldInstance class.
To use subclassing, follow the steps provided here. The Spell Caster code scripting example also
demonstrates how to use this, with a custom GoblinInstance class to represent the enemy
goblins in the game. A TypeScript version is also available. The code samples here use
JavaScript, but subclassing works similarly in TypeScript with the necessary type annotations see TypeScript in Construct.

Step 1: create your class
First write a class that extends from the class normally used by the instance. To help make this
easy, Construct creates a special kind of class for every kind of instance in the project in the
InstanceType namespace. For example when extending an object named Player, extend from
globalThis.InstanceType.Player .

Make sure your object names are valid JavaScript identifiers. Construct has more
permissive rules around naming objects, such as allowing them to start with a number, but
JavaScript names do not allow that. Invalid names may be adjusted by Construct, and the
easiest approach is to just make sure all your object names are also valid in JavaScript.
In this example we'll extend a Sprite instance for the object named Player, so the class extends
from globalThis.InstanceType.Player .
class PlayerInstance extends globalThis.InstanceType.Player
{
constructor()
{

Page 909 of 1146

Construct 3 Official Manual

super();
}
}

Often it is sensible to organize code by using a separate script file for the class.

Step 2: set the instance class
Next, use the IObjectClass.setInstanceClass() method to set your custom class. This must be
done before any instances in the project are created, to make sure they all use the right class.
Therefore this must be called in runOnStartup , which runs before the runtime has finished
loading, so no instances exist yet.
runOnStartup(async runtime =>
{
runtime.objects.Player.setInstanceClass(PlayerInstance);
}

Step 3: customise the class
Now you can add custom properties and methods to your class. For example the Player class
may need to use an ammo counter, and a shoot method to fire one of their bullets. You can write
these as you would with a normal JavaScript class.
class PlayerInstance extends globalThis.InstanceType.Player
{
constructor()
{
super();
// Start with 5 bullets
this.ammo = 5;
}
shoot()
{
// Decrement ammo count
this.ammo--;
// create a bullet instance, etc.
}
}

Note that here ammo is not an instance variable or anything else associated with Construct's
event system: it's just a normal JavaScript object property.

Page 910 of 1146

Construct 3 Official Manual

When using TypeScript, you'll need to use class fields to declare the property type. See
TypeScript in Construct for more details.
Since IInstance has a runtime property, within your class you can always use this.runtime to
refer to the runtime script interface.
You may also wish to make use of private properties and methods to ensure some details
remain internal to your class.
Over time as the Construct engine is improved, there are likely to be more properties and
methods added to the base classes. Your derived class's properties and methods override
any in base classes, so could potentially hide new APIs added in future. To avoid this
causing problems, try to use as specific names as possible that only apply to your project,
and avoid generic terms used elsewhere by Construct. If you want to be completely safe, use
a different naming scheme for your own additions, such as beginning every property with an
underscore. Also, name clashes will never occur with private properties or methods (starting
with # ), so it's a good idea to use those where you can.

Step 4: use your custom features
Now whenever you retrieve instances of the player from the existing APIs, you'll get
PlayerInstance classes instead of the default based on ISpriteInstance . Then you can read
your custom properties and call custom methods.
// Assume called in "beforelayoutstart" event
function OnBeforeLayoutStart(runtime)
{
// Get player instance from Construct
const playerInstance = runtime.objects.Player.getFirstInstance();
// Example uses of custom class
console.log("Ammo = " + playerInstance.ammo);
playerInstance.shoot();
}

Conclusion
Subclassing is straightforward to set up, and lets you use custom classes for different objects in
your project. This can make your code a lot clearer, and helps you to use the full power of
JavaScript/TypeScript classes with instances in Construct's runtime.

Page 911 of 1146

Construct 3 Official Manual

EXPORTING WITH ADVANCED
MINIFICATION
View online: https://www.construct.net/en/make-games/manuals/construct-3/scripting/guides/advancedminification

When exporting your project, there is an option to Minify script. This compresses all the
JavaScript code used both in the Construct engine and in your own scripts, and can help
obfuscate the project to make it more difficult to reverse-engineer. However if you choose the
Advanced mode, you may need to adjust how you write JavaScript code in Construct.
When using TypeScript the same adjustments also need to be made. The TypeScript compiler
essentially just removes type annotations and outputs regular JavaScript code which is then
what gets minified, so the rest of this guide focuses on JavaScript.
The minify mode None skips minifying scripts so they are not altered. Bundle only combines
multiple scripts into a single file without minifying. Simple mode eliminates whitespace and does
simple adjustments like renaming local variables to shorter names. This does not affect how any
of the code is run so is always safe to use. Advanced mode renames everything else, including
object properties, class method names, and so on. This process is referred to as property
mangling. It provides the best compression and obfuscation, but in some cases it can affect how
the code is run. Therefore you have to be aware of how it works and write your code accordingly
to safely use it.
Everything in the Construct engine supports Advanced mode. You only need to be careful
about using Advanced mode if you use the scripting feature to write JavaScript code in
Construct.

How property mangling works
Property mangling renames object properties to shorter names. For example consider the
following code:
const obj = {
apples: 1,
oranges: 2
};
console.log(obj.apples, obj.oranges);

This will log the numbers 1 and 2 as they correspond to the object properties apples and
oranges. After advanced minification the properties are renamed to shorter names, e.g.:

Page 912 of 1146

Construct 3 Official Manual

const obj = {
a: 1,
b: 2
};
console.log(obj.a, obj.b);

This is shorter code (which is faster to load) and harder to understand (which is harder to
reverse-engineer). It also works identically to how it did previously.

Avoiding renaming
In some cases there are specific names you don't want renamed. For example if you load an
external library at runtime and call a method like this:
externalLibrary.doSomethingUseful();

Property renaming will then change the name of the function, e.g.:
externalLibrary.a();

This then breaks the code, since it switched to calling a function that doesn't exist. The problem
is that the minification process doesn't know about code that comes from outside your own
scripts, and ends up renaming things it shouldn't.
To avoid this, you can use the string property syntax instead, as shown below.
externalLibrary["doSomethingUseful"]();

Advanced minification never renames string properties, so the name doSomethingUseful is
preserved even after minification, and the code continues to work.
To write a global name as a string property, access it as a property of globalThis , e.g.:
globalThis["myGlobalFunction"]();

Built-in names